# Язык L

LAst это Seq, While, If, Assign, Write или Read

Expr это Var, BinOp или Num

## Seq

всегда содержется внутри {}, переносы строк и пробелы тут игнорируются (только между инструкциями, если где-то внутри инструкций между словами были запрщены пробелы, то их все еще нельзя), разделитель между инструкциями ;

Т.е Seq ::= "{" ++ LAst ++ ("\n" | " ")* ++ ";" ++ ("\n" | " ")* ++ ... ++ "}"
Последовательно выполняет все инструкции внутри {}

## While

while(expr) пробелы запрещены как до () так и после, () обязательны, дальше идет Seq, т.е штука в {}.

Т.е While ::= "while(" ++ Expr ++ ")" ++ Seq

Выполняет Seq пока Expr истинно

## If

if() пробелы запрещены как до () так и после, дальше дальше идет Seq, т.е штука в {} потом после закрывающей скобки сразу else и сразу новый Seq.

Т.е If ::= "if(" ++ Expr ++ ")" ++ Seq ++ "else" ++ Seq

Выполняет первый Seq если Expr истинно иначе выполняет второй Seq

## Assign

:= пробелы справа и слева разрешены.

Т.е Assign ::= Var ++ "( )\*:=( )\*" ++ Expr

Связывает Expr с Var

## Read, Write

read(name) (аналогично write(expr)), пробелов между read (write) и скобками нет, между скобками и name(expr) игнорируются.

Т.е Read ::= "read(( )\*" ++ Var ++ "( )\*)"

для Write ::= "write(( )\*" ++ Expr ++ "( )\*)"

Первое читает число и связывает его с Var, второе пишет результат Expr

## Var

Последовательность символов (англ букв или цифр) неограниченной длинны при условии что первый символ - буква.
Все такие строковые штуки в выражениях разцениваются как имена переменных.

## Num

Много минусов нельзя, унарный плюс тоже.

## BinOp
`||`, `&&`, `==`, `/=`, `>=`, `>`, `<=`, `<`, `+`, `-` , `*`,  `/`, `^`, `-`
## UnaryOp
`-`, `!`

Приоритеты, ассоциативность и вычисление обычные, можно ставить скобки чтобы менять порядок вычисления.
Операндами являются другие Expr
