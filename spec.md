# Язык L

LAst это Seq, While, If, Assign, Write или Read

Expr это Var, BinOp или Num

## Seq

всегда содержется внутри {}, переносы строк и пробелы тут игнорируются (только между инструкциями или инструкциями и {}, если где-то внутри инструкций между словами были запрщены пробелы, то их все еще нельзя), разделитель между инструкциями ;

Т.е Seq ::= "{" ++ ("\n" | " ")* ++ (("\n" | " ")* ++ LAst ++ ("\n" | " ")* ++ ";")* ++ ("\n" | " ")* ++ "}"
Последовательно выполняет все инструкции внутри {}

## While

while(expr) пробелы запрещены как до () так и после, () обязательны, дальше идет Seq, т.е штука в {}.

Т.е While ::= "while(" ++ Expr ++ ")" ++ Seq

Выполняет Seq пока Expr истинно

## If

if() пробелы запрещены как до () так и после, дальше дальше идет Seq, т.е штука в {} потом после закрывающей скобки сразу else и сразу новый Seq.

Т.е If ::= "if(" ++ Expr ++ ")" ++ Seq ++ "else" ++ Seq

Выполняет первый Seq если Expr истинно иначе выполняет второй Seq

## Assign

:= пробелы справа и слева разрешены.

Т.е Assign ::= Var ++ "( )\*:=( )\*" ++ Expr

Связывает Expr с Var

## Read, Write

read(name) (аналогично write(expr)), пробелов между read (write) и скобками нет, между скобками и name(expr) игнорируются.

Т.е Read ::= "read(( )\*" ++ Var ++ "( )\*)"

для Write ::= "write(( )\*" ++ Expr ++ "( )\*)"

Первое читает число и связывает его с Var, второе пишет результат Expr

## Var

Последовательность символов (англ букв или цифр) неограниченной длинны при условии что первый символ - буква.
Все такие строковые штуки в выражениях разцениваются как имена переменных.

Если переменная используется в позиции обращения к ее значению, но при этом она не была инициализирована, то никаких гарантий на поведение нет.

## Num

Много минусов нельзя, унарный плюс тоже.

## Function

имена функций всегда начинаются "__." и заканчиваются ".__" 

При определении в круглых скобках через ", " перечисляются параметры, так же с круглых скобках в соответствующем порядке они перечисляются при вызове.

т.е определение функции ::= "__." ++ (корректное имя переменной) ++ ".__" ++ "(" ++ (Var + ", ")* ++ (Var)? ++ ")" + Seq

где Seq тело функции, чтобы вернуться есть инструкция "__..return..__(AST)" (т.е функция обязательно что-то возвращает) (пробелов нет да)

вызов функции ::= "__." ++ name ".__" ++ "(" ++ (AST + ", ")* ++ (AST)? ++ ")"

объявление допустимо только наверху, т.е между объявлениями функций ничего из LAst нет.

## BinOp
`||`, `&&`, `==`, `/=`, `>=`, `>`, `<=`, `<`, `+`, `-` , `*`,  `/`, `^`, `-`
## UnaryOp
`-`, `!`

Приоритеты, ассоциативность и вычисление обычные, можно ставить скобки чтобы менять порядок вычисления.
Операндами являются другие Expr
